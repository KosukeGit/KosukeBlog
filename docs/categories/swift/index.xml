<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swift on Kosuke Blog</title>
    <link>https://kosukeblog.com/categories/swift/index.xml</link>
    <description>Recent content in Swift on Kosuke Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <atom:link href="https://kosukeblog.com/categories/swift/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Abstract Factory パターンについて</title>
      <link>https://kosukeblog.com/2017/09/abstractfactory/</link>
      <pubDate>Fri, 15 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kosukeblog.com/2017/09/abstractfactory/</guid>
      <description>

&lt;h2 id=&#34;abstract-factory-パターンとは&#34;&gt;Abstract Factory パターンとは&lt;/h2&gt;

&lt;p&gt;デザインパターンの1つで、関連するオブジェクトの生成を行うクラスを抽象的にして、生成を行うためのインターフェースを提供する。&lt;/p&gt;

&lt;p&gt;インスタンスを生成するためのAPIを集約することにより、情報隠蔽や複数のモジュールの再利用を効率よく行うことが可能になる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;実装例&#34;&gt;実装例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;import UIKit



/// Abstract Factory パターン ----------------------------------------

/// Productクラス（製品）
protocol Doll {
    func sayHallo()
}

/// Creatorクラス（工場）
protocol Factory {
    func createInstance() -&amp;gt; Doll
}

/// ConcreteProductクラス（Japanese製品）
class JapaneseDoll: Doll {
    func sayHallo() {
        print(&amp;quot;こんにちは&amp;quot;)
    }
}

/// ConcreteProductクラス（America製品）
class AmericanDoll: Doll {
    func sayHallo() {
        print(&amp;quot;Hallo&amp;quot;)
    }
}

/// ConcreteCreatorクラス（Chinese製品）
class ChineseDoll: Doll {
    func sayHallo() {
        print(&amp;quot;你好&amp;quot;)
    }
}

/// Abstract Factory（XXのConcreteCreatorクラス（XX製品を作るXX工場）を作るFactoryメソッド）
enum Country {
    case Japan
    case America
    case China
}

enum DollFactory {
    static func create(from country: Country) -&amp;gt; Doll {
        switch country {
        case .Japan:
            return JapaneseDoll()
        case .America:
            return AmericanDoll()
        case .China:
            return ChineseDoll()
        }
    }
}



/// 呼び出す ------------------------------------------------------------

class ViewController: UIViewController {
    
    var doll: Doll { return DollFactory.create(from: .Japan) }  // 例えば .Japan を .America に変えるだけでAmericanDollのインスタンスが生成できる
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        doll.sayHallo()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Abstract FactoryでDollオブジェクトをインスタンス化する役割を持つ。&lt;br /&gt;
そのため、呼び出し側で生成されるインスタンスのことを意識しなくて済む（状況が変わっても修正箇所は微量且つ呼び出す側のコードに影響がない）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift プロトコル、デリゲートについて理解する</title>
      <link>https://kosukeblog.com/2017/09/protocol/</link>
      <pubDate>Fri, 15 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kosukeblog.com/2017/09/protocol/</guid>
      <description>

&lt;p&gt;プロトコルやデリゲートの使い方などの基礎を初心にかえって勉強し直してみました。&lt;br /&gt;
Swiftのプロトコルは、Javaでいうインターフェースのことです。&lt;br /&gt;
Swiftのプロトコルだけで学ぼうとすると、少々わかりづらいかもしれないので、&lt;br /&gt;
Javaのインターフェースを先に調べてみてからだと、より理解しやすいかと思います。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;また、本記事ではステップごとに分けて実際のプログラムで解説してきます。&lt;br /&gt;
&lt;del&gt;決して手抜き解説なわけではありません。&lt;/del&gt;&lt;/p&gt;

&lt;h5 id=&#34;step-1-1&#34;&gt;Step 1-1&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;import Foundation

/// クラスがカートを持つ上で、カートに必要な要素をここで定義する
/// ちなみにプロトコルはただのお約束という意味なので
/// 必ずしもDelegateと名付ける必要はない
protocol KartDelegate {
    func setPerformance()  // 性能
    func setColor()  // 車の色
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;step-1-2&#34;&gt;Step 1-2&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;import Foundation

/// カートプロトコル
protocol KartDelegate {
    func setPerformance()  // 性能
    func setColor()  // 車の色
}

/// マリオクラスがカートを持つ
class Mario: KartDelegate {
    
    /// カートを持ったクラスは、そのカートプロトコルの中で定義した抽象メソッドを
    /// 必ず実装（implements）してあげる必要がある
    func setPerformance() {
        print(&amp;quot;☆☆☆☆☆&amp;quot;)
    }
    func setColor() {
        print(&amp;quot;Red&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;step-1-3&#34;&gt;Step 1-3&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;import Foundation

/// クラスがカートを持つ上で、カートに必要な要素をここで定義する
protocol KartDelegate {
    func setPerformance()  // 性能
    func setColor()  // 車の色
}

/// マリオクラス
class Mario {
    /// どんなカートを持つかわからないがKartDelegateのプロパティを持つ
    var delegate: KartDelegate?
    
    func myKart() {
        /// まだどんなカートを持っているかわからないがここで呼び出してみる
        delegate?.setPerformance()
        delegate?.setColor()
    }
}

/// ルイージクラス
class Luigi: KartDelegate {
    
    func setPerformance() {
        print(&amp;quot;☆☆&amp;quot;)
    }
    func setColor() {
        print(&amp;quot;Green&amp;quot;)
    }
}

/// クラスのインスタンスを作る
let mario = Mario()
let luigi = Luigi()
/// ここでマリオがdelegateを通じてルイージのカートを持つ
mario.delegate = luigi
mario.myKart()  // ☆☆ Green
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;実際に使用する例&#34;&gt;実際に使用する例&lt;/h3&gt;

&lt;p&gt;iOSアプリを開発している方で、tabelViewやtextFieldなどを利用する際に&lt;br /&gt;
どこかの記事の通り書いて、知らぬ間にクラスに&lt;code&gt;~~~Delegate&lt;/code&gt;を継承して、
プロトコルの関数を使用していた、、なんて経験があるかもしれません。&lt;/p&gt;

&lt;p&gt;ここまででプロトコル等について理解できてきたなら&lt;br /&gt;
下記の例を見れば、より理解が深まるかもしれません。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;step-2-1&#34;&gt;Step 2-1&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;import UIKit

class ViewController: UIViewController, UITextFieldDelegate {  // UITextFieldDelegateのプロトコルを継承する
    
    @IBOutlet weak var textField: UITextField!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        textField.delegate = self  // command + クリック で delegate の中身を見ると
                                   // weak open var delegate: UITextFieldDelegate? が定義されているのがわかる。
                                   // また、このクラス内でプロトコルの関数の中身の実装をしており、
                                   // その関数を扱いたいため self をデリゲートに指定してある。
                                   // ちなみに、定義元が optional public func ~~ のように optional が付いているものは
                                   // 必ずしもプロトコルの関数を実装（implements）する必要はない。
    }
    
    /// デリゲートをselfにしてあるので、この中にUITextFieldDelegateの関数を記述する
    /// Returnボタン後にキーボードを閉じる
    func textFieldShouldReturn(_ textField: UITextField) -&amp;gt; Bool {
        textField.resignFirstResponder()
        return true
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;step-2-2&#34;&gt;Step 2-2&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;/// このように外でUITextFieldDelegateを継承して、実装したプロトコルの関数を
/// デリゲートで指定してあげればViewControllerで使うこともできる。
/// しかし、この方法を用いる場合はクラスのインスタンスが破棄されると扱えなくなるので注意が必要です。

import UIKit

class ViewController: UIViewController {
    
    @IBOutlet weak var textField: UITextField!
    let vc2 = ViewController2()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        textField.delegate = vc2
    }
}

class ViewController2: UIViewController, UITextFieldDelegate {
    /// Returnボタン後にキーボードを閉じる
    func textFieldShouldReturn(_ textField: UITextField) -&amp;gt; Bool {
        textField.resignFirstResponder()
        return true
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コードを書く際に、まず動かそうと真似て書いて、&lt;br /&gt;
なんとなく理解した気になっていたことが度々ありましたが、&lt;br /&gt;
こうして改めてステップごとにわけて書いてみると自分でもより理解を深めることができました。:)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>