<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kosuke Blog</title>
    <link>https://kosukeblog.com/archives/index.xml</link>
    <description>Recent content on Kosuke Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <atom:link href="https://kosukeblog.com/archives/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Abstract Factory パターンについて</title>
      <link>https://kosukeblog.com/2017/09/abstractfactory/</link>
      <pubDate>Fri, 15 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kosukeblog.com/2017/09/abstractfactory/</guid>
      <description>

&lt;h2 id=&#34;abstract-factory-パターンとは&#34;&gt;Abstract Factory パターンとは&lt;/h2&gt;

&lt;p&gt;デザインパターンの1つで、関連するオブジェクトの生成を行うクラスを抽象的にして、生成を行うためのインターフェースを提供する。&lt;/p&gt;

&lt;p&gt;インスタンスを生成するためのAPIを集約することにより、情報隠蔽や複数のモジュールの再利用を効率よく行うことが可能になる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;実装例&#34;&gt;実装例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;import UIKit



/// Abstract Factory パターン ----------------------------------------

/// Productクラス（製品）
protocol Doll {
    func sayHallo()
}

/// Creatorクラス（工場）
protocol Factory {
    func createInstance() -&amp;gt; Doll
}

/// ConcreteProductクラス（Japanese製品）
class JapaneseDoll: Doll {
    func sayHallo() {
        print(&amp;quot;こんにちは&amp;quot;)
    }
}

/// ConcreteProductクラス（America製品）
class AmericanDoll: Doll {
    func sayHallo() {
        print(&amp;quot;Hallo&amp;quot;)
    }
}

/// ConcreteCreatorクラス（Chinese製品）
class ChineseDoll: Doll {
    func sayHallo() {
        print(&amp;quot;你好&amp;quot;)
    }
}

/// Abstract Factory（XXのConcreteCreatorクラス（XX製品を作るXX工場）を作るFactoryメソッド）
enum Country {
    case Japan
    case America
    case China
}

enum DollFactory {
    static func create(from country: Country) -&amp;gt; Doll {
        switch country {
        case .Japan:
            return JapaneseDoll()
        case .America:
            return AmericanDoll()
        case .China:
            return ChineseDoll()
        }
    }
}



/// 呼び出す ------------------------------------------------------------

class ViewController: UIViewController {
    
    var doll: Doll { return DollFactory.create(from: .Japan) }  // 例えば .Japan を .America に変えるだけでAmericanDollのインスタンスが生成できる
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        doll.sayHallo()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Abstract FactoryでDollオブジェクトをインスタンス化する役割を持つ。&lt;br /&gt;
そのため、呼び出し側で生成されるインスタンスのことを意識しなくて済む（状況が変わっても修正箇所は微量且つ呼び出す側のコードに影響がない）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift プロトコル、デリゲートについて理解する</title>
      <link>https://kosukeblog.com/2017/09/protocol/</link>
      <pubDate>Fri, 15 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kosukeblog.com/2017/09/protocol/</guid>
      <description>

&lt;p&gt;プロトコルやデリゲートの使い方などの基礎を初心にかえって勉強し直してみました。&lt;br /&gt;
Swiftのプロトコルは、Javaでいうインターフェースのことです。&lt;br /&gt;
Swiftのプロトコルだけで学ぼうとすると、少々わかりづらいかもしれないので、&lt;br /&gt;
Javaのインターフェースを先に調べてみてからだと、より理解しやすいかと思います。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;また、本記事ではステップごとに分けて実際のプログラムで解説してきます。&lt;br /&gt;
&lt;del&gt;決して手抜き解説なわけではありません。&lt;/del&gt;&lt;/p&gt;

&lt;h5 id=&#34;step-1-1&#34;&gt;Step 1-1&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;import Foundation

/// クラスがカートを持つ上で、カートに必要な要素をここで定義する
/// ちなみにプロトコルはただのお約束という意味なので
/// 必ずしもDelegateと名付ける必要はない
protocol KartDelegate {
    func setPerformance()  // 性能
    func setColor()  // 車の色
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;step-1-2&#34;&gt;Step 1-2&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;import Foundation

/// カートプロトコル
protocol KartDelegate {
    func setPerformance()  // 性能
    func setColor()  // 車の色
}

/// マリオクラスがカートを持つ
class Mario: KartDelegate {
    
    /// カートを持ったクラスは、そのカートプロトコルの中で定義した抽象メソッドを
    /// 必ず実装（implements）してあげる必要がある
    func setPerformance() {
        print(&amp;quot;☆☆☆☆☆&amp;quot;)
    }
    func setColor() {
        print(&amp;quot;Red&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;step-1-3&#34;&gt;Step 1-3&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;import Foundation

/// クラスがカートを持つ上で、カートに必要な要素をここで定義する
protocol KartDelegate {
    func setPerformance()  // 性能
    func setColor()  // 車の色
}

/// マリオクラス
class Mario {
    /// どんなカートを持つかわからないがKartDelegateのプロパティを持つ
    var delegate: KartDelegate?
    
    func myKart() {
        /// まだどんなカートを持っているかわからないがここで呼び出してみる
        delegate?.setPerformance()
        delegate?.setColor()
    }
}

/// ルイージクラス
class Luigi: KartDelegate {
    
    func setPerformance() {
        print(&amp;quot;☆☆&amp;quot;)
    }
    func setColor() {
        print(&amp;quot;Green&amp;quot;)
    }
}

/// クラスのインスタンスを作る
let mario = Mario()
let luigi = Luigi()
/// ここでマリオがdelegateを通じてルイージのカートを持つ
mario.delegate = luigi
mario.myKart()  // ☆☆ Green
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;実際に使用する例&#34;&gt;実際に使用する例&lt;/h3&gt;

&lt;p&gt;iOSアプリを開発している方で、tabelViewやtextFieldなどを利用する際に&lt;br /&gt;
どこかの記事の通り書いて、知らぬ間にクラスに&lt;code&gt;~~~Delegate&lt;/code&gt;を継承して、
プロトコルの関数を使用していた、、なんて経験があるかもしれません。&lt;/p&gt;

&lt;p&gt;ここまででプロトコル等について理解できてきたなら&lt;br /&gt;
下記の例を見れば、より理解が深まるかもしれません。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;step-2-1&#34;&gt;Step 2-1&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;import UIKit

class ViewController: UIViewController, UITextFieldDelegate {  // UITextFieldDelegateのプロトコルを継承する
    
    @IBOutlet weak var textField: UITextField!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        textField.delegate = self  // command + クリック で delegate の中身を見ると
                                   // weak open var delegate: UITextFieldDelegate? が定義されているのがわかる。
                                   // また、このクラス内でプロトコルの関数の中身の実装をしており、
                                   // その関数を扱いたいため self をデリゲートに指定してある。
                                   // ちなみに、定義元が optional public func ~~ のように optional が付いているものは
                                   // 必ずしもプロトコルの関数を実装（implements）する必要はない。
    }
    
    /// デリゲートをselfにしてあるので、この中にUITextFieldDelegateの関数を記述する
    /// Returnボタン後にキーボードを閉じる
    func textFieldShouldReturn(_ textField: UITextField) -&amp;gt; Bool {
        textField.resignFirstResponder()
        return true
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;step-2-2&#34;&gt;Step 2-2&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;/// このように外でUITextFieldDelegateを継承して、実装したプロトコルの関数を
/// デリゲートで指定してあげればViewControllerで使うこともできる。
/// しかし、この方法を用いる場合はクラスのインスタンスが破棄されると扱えなくなるので注意が必要です。

import UIKit

class ViewController: UIViewController {
    
    @IBOutlet weak var textField: UITextField!
    let vc2 = ViewController2()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        textField.delegate = vc2
    }
}

class ViewController2: UIViewController, UITextFieldDelegate {
    /// Returnボタン後にキーボードを閉じる
    func textFieldShouldReturn(_ textField: UITextField) -&amp;gt; Bool {
        textField.resignFirstResponder()
        return true
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コードを書く際に、まず動かそうと真似て書いて、&lt;br /&gt;
なんとなく理解した気になっていたことが度々ありましたが、&lt;br /&gt;
こうして改めてステップごとにわけて書いてみると自分でもより理解を深めることができました。:)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Developer Enterprise Program を使ってアプリ配布したときのまとめ</title>
      <link>https://kosukeblog.com/2017/08/inhouse/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kosukeblog.com/2017/08/inhouse/</guid>
      <description>

&lt;p&gt;本記事は、In-House形式によるiOSアプリの配布方法です。&lt;br /&gt;
ダウンロードできるデバイスをこちらで登録する必要なく、台数無制限でアプリを入れることが可能です。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;developer-enterprise-program-配布までの流れ&#34;&gt;Developer Enterprise Program 配布までの流れ&lt;/h1&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;①-archives&#34;&gt;① Archives&lt;/h5&gt;

&lt;p&gt;端末を Generic iOS Device にして &lt;code&gt;Product&lt;/code&gt; -&amp;gt; &lt;code&gt;Archives&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;②-ipaファイルの生成&#34;&gt;② ipaファイルの生成&lt;/h5&gt;

&lt;p&gt;Export で ipa ファイルを作る&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;アプリの名前（Xcode側で設定したアイコン名はアプリをインストールしている時に表示される時に表示される名前）&lt;/li&gt;
&lt;li&gt;ダウンロードページからダウンロードを押した時にダウンロードされるipaファイルのURL&lt;br /&gt;
例: &lt;code&gt;https://ダウンロードページ/アプリ名.ipa&lt;/code&gt;&lt;br /&gt;
（plistファイルからこのURLを参照してダウンロードさせるのに使用）&lt;/li&gt;
&lt;li&gt;image URL ×2 (大小)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;具体例は下記に記載してある &lt;em&gt;GitHubでダウンロードページを動かす&lt;/em&gt; を参照&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/jp/documentation/IDEs/Conceptual/AppDistributionGuide/DistributingEnterpriseProgramApps/DistributingEnterpriseProgramApps.html&#34;&gt;参考URL - Apple公式ページ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;③-ダウンロードページを作る&#34;&gt;③ ダウンロードページを作る&lt;/h5&gt;

&lt;p&gt;ダウンロードボタンを押したときに手順2で生成されるplistファイルをここで読みこませる&lt;br /&gt;
例: &lt;code&gt;https://ダウンロードページ/manifest.plist&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;例: ダウンロードページのHTML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;ja&amp;quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;ダウンロードページ&amp;lt;/title&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

    &amp;lt;h1&amp;gt;ダウンロード&amp;lt;/h1&amp;gt;

    &amp;lt;img src=&amp;quot;./image/icon512.png&amp;quot; alt=&amp;quot;アプリアイコン&amp;quot;&amp;gt;
    &amp;lt;p&amp;gt;下のボタンからアプリをダウンロードしてください。&amp;lt;/p&amp;gt;

    &amp;lt;a href=&amp;quot;itms-services://?action=download-manifest&amp;amp;url=manifest.plistが置いてあるURL&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;ダウンロード&amp;lt;/a&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Export時に&lt;code&gt;ipaファイル&lt;/code&gt;と&lt;code&gt;plistファイル&lt;/code&gt;が生成されるため、&lt;br /&gt;
&lt;code&gt;itms-services://?action=download-manifest&amp;amp;url=&lt;/code&gt;の後に&lt;br /&gt;
生成したplistファイルの置いてあるURLを指定します。&lt;/p&gt;

&lt;p&gt;例: &lt;code&gt;&amp;lt;a href=&amp;quot;itms-services://?action=download-manifest&amp;amp;url=https://ユーザ名.github.io/アプリ名/download/apps/v1_0_0/manifest.plist&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;ダウンロード&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;githubでダウンロードページを動かす&#34;&gt;GitHubでダウンロードページを動かす&lt;/h5&gt;

&lt;p&gt;ページにアクセスできるようにするための具体例として、&lt;br /&gt;
GitHubでダウンロードする静的ページを作り、
同一階層にipa, plistファイルを置くという方法があります。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;例: GitHub構成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;アプリ名 - download  / - apps  /  v1_0_0  /  - アプリ名.ipa
                                           - manifest.plist
                     - image /  - icon512.png
                                - icon57.png
                     - index.html
                     - style.css
       - README.md
       - .gitignore
       - LICENSE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リポジトリ内をこのようなファイル構成にしておき、&lt;br /&gt;
githubで静的サイトを作り、  URLを生成すると&lt;br /&gt;
XcodeでExportする際に必要なURLが以下のようになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;https://ユーザ名.github.io/アプリ名/download/apps/v1_0_0/アプリ名.ipa&lt;/li&gt;
&lt;li&gt;https://ユーザ名.github.io/アプリ名/download/image/icon57.png&lt;/li&gt;
&lt;li&gt;https://ユーザ名.github.io/アプリ名/download/image/icon512.png&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;これであとは、手持ちの端末からサイトにアクセスして&lt;br /&gt;
&lt;code&gt;ダウンロード完了&lt;/code&gt; -&amp;gt; &lt;code&gt;設定&lt;/code&gt; -&amp;gt; &lt;code&gt;プロファイルとデバイス管理&lt;/code&gt; を選択し、&lt;br /&gt;
エンタープライズAPPにある項目から該当するアプリ開発者を選び、&lt;code&gt;信頼&lt;/code&gt;を選択する。&lt;br /&gt;
これで、利用できるようになります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Xcodeで色設定をするときの注意点</title>
      <link>https://kosukeblog.com/2017/07/color/</link>
      <pubDate>Mon, 31 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kosukeblog.com/2017/07/color/</guid>
      <description>

&lt;h2 id=&#34;xcodeで色設定をするときの注意点&#34;&gt;Xcodeで色設定をするときの注意点&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;動機&#34;&gt;動機&lt;/h3&gt;

&lt;p&gt;Storyboardで設定した色とコードで書いた色の見た目が&lt;br /&gt;
Build&amp;amp;Runして確認したときに微妙に違うなあと思い、&lt;br /&gt;
調べたところ以下の設定が問題でした。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;原因と解決方法&#34;&gt;原因と解決方法&lt;/h3&gt;

&lt;p&gt;Xcode の色選択から &lt;strong&gt;RGB Sliders&lt;/strong&gt; を選択し、&lt;br /&gt;
右の歯車マークから &lt;strong&gt;Color Profile&lt;/strong&gt; で確認したところ設定が異なっていたのが原因でした。&lt;br /&gt;
そのため、自分の場合は &lt;code&gt;Generic RGB&lt;/code&gt; -&amp;gt; &lt;code&gt;sRGB&lt;/code&gt;に設定を変えて色を統一させました。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;おまけ&#34;&gt;おまけ&lt;/h3&gt;

&lt;p&gt;ちなみに正確な色の値を知りたい場合は&lt;br /&gt;
こちらを使用すると見ることができます。&lt;br /&gt;
&lt;code&gt;Spotlight検索&lt;/code&gt; -&amp;gt; &lt;code&gt;Digital Color Meter&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Xcode空白の設定 &#43; 小ネタ</title>
      <link>https://kosukeblog.com/2017/06/whitespace/</link>
      <pubDate>Fri, 30 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kosukeblog.com/2017/06/whitespace/</guid>
      <description>

&lt;h2 id=&#34;xcodeで空白の設定をする-小ネタ&#34;&gt;Xcodeで空白の設定をする + 小ネタ&lt;/h2&gt;

&lt;p&gt;Info.plistをコードの状態にして一部修正を加えた際、空白の種類が異なってしまっていたのでメモ。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Xcode -&amp;gt; Preferences&amp;hellip; -&amp;gt; Text Editing を選択&lt;br /&gt;
その中にある項目の Indentation の Prefer indent using を押すと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Spaces&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tabs&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の２種類が選択できる。&lt;/p&gt;

&lt;p&gt;上記の2種類からどちらかで統一し、文字をコピペし直すと自動的に空白を指定した方の設定で補ってくれます。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;空白を目で確認する方法&#34;&gt;空白を目で確認する方法&lt;/h5&gt;

&lt;p&gt;Xcodeの上のメニューから &lt;code&gt;Editor&lt;/code&gt; -&amp;gt; &lt;code&gt;Show Invisibles&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;小ネタ&#34;&gt;小ネタ&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;?w=1&lt;/code&gt;をGitHubのリンクの後ろに付けると空白の差分を除いた状態になるためレビューしやすくなります！試して見てください:)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>gitignoreについて</title>
      <link>https://kosukeblog.com/2017/05/gitignore/</link>
      <pubDate>Sun, 21 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kosukeblog.com/2017/05/gitignore/</guid>
      <description>

&lt;h2 id=&#34;gitignore-とは&#34;&gt;.gitignore とは&lt;/h2&gt;

&lt;p&gt;&amp;ldquo;ignore = 無視する&amp;rdquo;という意味の通り、Gitのバージョン管理の対象から外すファイル（＝無視するファイル）を .gitignore に書いておき、その設定ファイルをルートディレクトリに置いておくことで git add . などを行ったときでもそのファイルだけ自動で無視をするようになります。そのため、間違えてプッシュしてしまったといったことを回避することができます。&lt;/p&gt;

&lt;h3 id=&#34;生成の仕方&#34;&gt;生成の仕方&lt;/h3&gt;

&lt;p&gt;ターミナルで vim .gitignore を打つことによって .gitignore が生成され、vim が立ち上がります。i コマンドで insertモードに切り替え、中に対象のファイルを書き込んでいきます。（書き方については後述します）その後、escキーを押して :wq で保存&amp;amp;終了を行います。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;書き方&#34;&gt;書き方&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;\#&lt;/code&gt;：&lt;strong&gt;コメント&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;*.ipa&lt;/code&gt;：&lt;strong&gt;その拡張子はすべて無視したいとき&lt;/strong&gt;&lt;br /&gt;
→ .ipa のつく拡張子はすべて無視する。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;/test&lt;/code&gt;：&lt;strong&gt;このファイルの全てを無視する&lt;/strong&gt;&lt;br /&gt;
→ 末尾に / がない場合は test と test 以下のファイル or ディレクトリを無視する。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;test/&lt;/code&gt;：&lt;strong&gt;その名前のディレクトリ全て無視される&lt;/strong&gt;&lt;br /&gt;
→ ルートディレクトリとそのサブディレクトリ内の test というディレクトリ名全てを無視する&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;~~/~~/test/（~~/~~/test）&lt;/code&gt;：&lt;strong&gt;そのファイル or ディレクトリのみ無視する&lt;/strong&gt;&lt;br /&gt;
→ 最初と最後が / の時はそのファイル or ディレクトリのみを指定して無視する。この場合は test のみを無視する。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;!/~~/~~/test.text&lt;/code&gt;：&lt;strong&gt;無視するのを無効にする&lt;/strong&gt;（＝そのファイルは無視しない）&lt;br /&gt;
→ 例えば * で書いてあるとき、その中の test.text は無視したくないときに使用する。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;他にも書き方がありますが、とりあえずはこのあたりを押さえておくといいと思います。
また、実際に使用する際には&lt;strong&gt;&lt;a href=&#34;https://github.com/github/gitignore&#34;&gt;ここ&lt;/a&gt;&lt;/strong&gt;から対象のもの（例えば Swift で書いているのであれば Swift.gitignore ）を見るなどして参考にするとよいと思います。&lt;br /&gt;
初めは、そのファイル自体をクローンしてリネーム（.gitignore に変更）してルートディレクトリ直下に入れておけばコンフリクトなどの回避をすることができます。
ちなみにリネームする際はターミナルから行います。（Swift.gitignore  から .gitignore  にリネームする時：&lt;code&gt;mv Swift.gitignore .gitignore&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;また、隠しフォルダをファインダーで開く際は、&lt;code&gt;command + shift + .&lt;/code&gt; で見ることが可能です！&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;補足&#34;&gt;補足&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;GitHub上から .gitignore の設定を行う場合&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Create a new repository で新しいリポジトリの作成時に下の方に&lt;code&gt;Add  .gitignore: None&lt;/code&gt;となっているところがあるので、そこを押して使用する言語のものを選択すれば自動で生成してくれます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gitのコマンド名を自分で設定する</title>
      <link>https://kosukeblog.com/2017/05/command/</link>
      <pubDate>Sun, 07 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kosukeblog.com/2017/05/command/</guid>
      <description>

&lt;p&gt;Gitコマンドが長くて打つのが大変、毎回調べなきゃいけない&amp;hellip; そんなときに以下のような設定をすることによってGitのショートカットコマンドを作成することができます！&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--global&lt;/code&gt; にすることで現在のユーザーを対象にした設定をすることができます。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;エイリアス設定&#34;&gt;エイリアス設定&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;git config --global alias.省略したいコマンド &#39;実際のコマンド&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;例：git config --global alias.st &#39;status&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;実行時&#34;&gt;実行時&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;git st
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで git status した時と同じ動作をするようになります&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;設定したエイリアス一覧表示&#34;&gt;設定したエイリアス一覧表示&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;git config --global --list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;設定したコマンドを削除&#34;&gt;設定したコマンドを削除&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;git config --global --unset alias.st
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで  git st コマンドが削除されます&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;ヘルプ表示&#34;&gt;ヘルプ表示&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;git config help
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;参考URLは&lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Basics-Git-Aliases&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;おまけ&#34;&gt;おまけ&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;今日何をしたか振り返り-１２時間前からのログ表示&#34;&gt;今日何をしたか振り返り（１２時間前からのログ表示）&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;git today
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコマンドで今日どんなコミットをしたか等振り返ることができます。&lt;/p&gt;

&lt;p&gt;設定する際はこちら↓&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config --global alias.today &amp;quot;log --oneline --since=&#39;12 hours ago&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;ログをグラフで表示&#34;&gt;ログをグラフで表示&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;git mylog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ターミナルでログをグラフにして確認する際に便利です。&lt;/p&gt;

&lt;p&gt;設定する際はこちら↓&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config --global alias.mylog &#39;log --oneline --graph --decorate&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;これでよく使うコマンドや長いコマンドの入力が楽になります。
何を設定したか確認したい時は、&lt;code&gt;--list&lt;/code&gt;を使いましょう！&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;こちらの記事も合わせてどうぞ！&lt;/p&gt;

&lt;p&gt;→ &lt;a href=&#34;https://kosukeblog.com/2017/04/completion/&#34;&gt;tabキーでGitのコマンドを補完する&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>いいねやツイートボタンのURLまとめ</title>
      <link>https://kosukeblog.com/2017/05/button/</link>
      <pubDate>Sat, 06 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kosukeblog.com/2017/05/button/</guid>
      <description>&lt;p&gt;自分のブログに、いいねや記事をシェアしてもらうためのボタンのURLをまとめました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://about.twitter.com/ja/resources/buttons#tweet&#34;&gt;Twitter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://b.hatena.ne.jp/guide/bbutton&#34;&gt;はてブ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developers.facebook.com/docs/plugins/like-button?locale=ja_JP#&#34;&gt;Facebook&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developers.google.com/+/web/+1button/&#34;&gt;Google+&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://getpocket.com/publisher/button&#34;&gt;Pocket&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://media.line.me/ja/how_to_install#lineitbutton&#34;&gt;LINE&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://feedly.com/factory.html&#34;&gt;feedly&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dev.evernote.com/sitememory/#a_builder&#34;&gt;Evernote&lt;/a&gt;　※廃止のため、現在は &lt;a href=&#34;https://evernote.com/intl/jp/webclipper/&#34;&gt;Web Clipper&lt;/a&gt; を用いる&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.tumblr.com/buttons&#34;&gt;Tumblr&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://developer.mixi.co.jp/connect/mixi_plugin/mixi_check/spec_mixi_check/&#34;&gt;mixi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Facebookのいいねボタンは普通に配置しただけでは少し下にずれてしまうことがあるので、htmlで書く場合は&lt;/p&gt;

&lt;p&gt;&lt;code&gt;style=&amp;quot;line-height:0;&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;の記述をタグの中にすると他のボタンと同じ高さになります。&lt;/p&gt;

&lt;p&gt;また、Google+ や Pocket は右側に空白ができてしまうため、気になる場合は横幅(width)を調節してあげると良いと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GitHubの２段階認証後にpushできなくなった時の対処法</title>
      <link>https://kosukeblog.com/2017/05/authentication/</link>
      <pubDate>Fri, 05 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kosukeblog.com/2017/05/authentication/</guid>
      <description>&lt;p&gt;今回は、GitHubで２段階認証を行ったが、その後のpushができなくなってしまった際の対応方法について書いていきたいと思います。&lt;/p&gt;

&lt;p&gt;下記の様にプッシュ後にユーザ名とパスワードを求められて、入力すると&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fatal: Authentication failed for &#39;https://github.com/~~~&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;と出力されてしまいました。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;この対応方法は、アクセストークンを生成する必要があります。
公式ページに従って手順通りに行えば解決できます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/&#34;&gt;Creating a token&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まず、上記のURLの手順に従ってアクセストークンを発行します。
このアクセストークンはどこかにメモをしておきましょう。&lt;/p&gt;

&lt;p&gt;そして、ユーザ名とパスワードを入力する際のパスワードに先ほどのアクセストークンを入れて進めることでプッシュすることができます。&lt;/p&gt;

&lt;p&gt;ちなみに、キーチェーン等の確認をする際はこちらを参考にすると良いです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://help.github.com/articles/updating-credentials-from-the-osx-keychain/&#34;&gt;Updating your credentials via Keychain Access&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CocoaPodsについて</title>
      <link>https://kosukeblog.com/2017/04/cocoapods/</link>
      <pubDate>Thu, 13 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kosukeblog.com/2017/04/cocoapods/</guid>
      <description>

&lt;h2 id=&#34;cocoapods-https-cocoapods-org&#34;&gt;&lt;a href=&#34;https://cocoapods.org/&#34;&gt;CocoaPods&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;オープンソースなどのライブラリを使用した際にバージョン管理を行うことができるiOSライブラリ管理ツール&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;インストール&#34;&gt;インストール&lt;/h5&gt;

&lt;p&gt;CocoaPods をインストールする&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gem install cocoapods
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;podfileの生成&#34;&gt;Podfileの生成&lt;/h5&gt;

&lt;p&gt;Podfile が入ってない場合は、一番最初に使用したいディレクトリで以下のコマンドを入力するとPodfileが生成される
（この中にライブラリなどを追加していく）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;workspace等の生成&#34;&gt;Workspace等の生成&lt;/h5&gt;

&lt;p&gt;pod install を行うとその中に以下のファイル等が生成される&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;アプリ名.xcworkspace&lt;/li&gt;
&lt;li&gt;Podfile.lock&lt;/li&gt;
&lt;li&gt;Podsフォルダ&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;pod install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;podのバージョンを更新する&#34;&gt;podのバージョンを更新する&lt;/h5&gt;

&lt;p&gt;podのバージョンをあげる際に以下のコマンドを使用する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;編集&#34;&gt;編集&lt;/h5&gt;

&lt;p&gt;バージョンの書き換えなどを行う際に使用する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi Podfile
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert danger &#34;&gt;
  &lt;p&gt;最後に &lt;strong&gt;pod install&lt;/strong&gt; をしないと反映されないので注意&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;ファイル内の確認&#34;&gt;ファイル内の確認&lt;/h5&gt;

&lt;p&gt;podファイルの中を確認する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat Podfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;古いバージョンの検出&#34;&gt;古いバージョンの検出&lt;/h5&gt;

&lt;p&gt;使用しているライブラリの中から古いバージョンを検出してくれる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod outbated
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;コマンドのヘルプ&#34;&gt;コマンドのヘルプ&lt;/h5&gt;

&lt;p&gt;コマンドを忘れた際に使用する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod --help
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;使用する際には アプリ名.xcworkspace を開いて、その中に使うライブラリのインポート行う必要があります。&lt;/p&gt;

&lt;p&gt;また、多数のライブラリ等がまとまった &lt;a href=&#34;https://github.com/matteocrippa/awesome-swift&#34;&gt;Awesome Swift&lt;/a&gt; はおすすめです。ここから使いたいものを探してみるといいかもしれません。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bash-completion, git-completionの導入手順</title>
      <link>https://kosukeblog.com/2017/04/completion/</link>
      <pubDate>Wed, 12 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kosukeblog.com/2017/04/completion/</guid>
      <description>

&lt;p&gt;今回は、bash-completion と git-completionの導入の手順を記していきます。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;bash-completion&#34;&gt;bash-completion&lt;/h2&gt;

&lt;p&gt;bash-completionとは、Bashの補完機能を拡張するシェルスクリプトのことです。&lt;/p&gt;

&lt;h5 id=&#34;インストール&#34;&gt;インストール&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;$ brew install bash-completion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;viコマンドで追加する&#34;&gt;viコマンドで追加する&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;vi ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;i（インサートモードに移行）&lt;/li&gt;
&lt;li&gt;以下を追加（&lt;a href=&#34;https://github.com/scop/bash-completion&#34;&gt;参考ページ&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;escキー（インサートモードを解除）&lt;/li&gt;
&lt;li&gt;:wq（保存して終了）&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;if [ -f `brew --prefix`/etc/bash_completion ]; then
    . `brew --prefix`/etc/bash_completion
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;git-completion&#34;&gt;git-completion&lt;/h2&gt;

&lt;p&gt;git-completionとは、Gitコマンドの補完スクリプトのことです。&lt;/p&gt;

&lt;h5 id=&#34;インストール-1&#34;&gt;インストール&lt;/h5&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/git/git/blob/master/contrib/completion/git-completion.bash&#34;&gt;ここ&lt;/a&gt;からダウンロード&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Rawを開いて中身をコピー&lt;/li&gt;
&lt;li&gt;viコマンドで貼り付け&lt;/li&gt;
&lt;li&gt;:w 名前（今回は、名前のところを git-completion.bash とする）をつけて終了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;実行する&#34;&gt;実行する&lt;/h5&gt;

&lt;p&gt;作成した git-completion.bash をどこかのフォルダにいれる&lt;/p&gt;

&lt;p&gt;（例：setting/git-completion.bash）&lt;/p&gt;

&lt;p&gt;その後は以下を入力して、指定したスクリプトファイルを実行する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source ~/setting/git-completion.bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;これでターミナルでGitコマンドなどが入力途中で Tabキー を押すことによって最後まで自動で入力されて楽になります！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>このブログについて</title>
      <link>https://kosukeblog.com/2017/03/blog/</link>
      <pubDate>Fri, 10 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kosukeblog.com/2017/03/blog/</guid>
      <description>

&lt;p&gt;初めまして、&lt;a href=&#34;https://twitter.com/gt1028kn&#34;&gt;こうすけ&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;本日ブログを開設しました。
これまで技術的なことを主に&lt;a href=&#34;http://qiita.com/KosukeQiita&#34;&gt;Qiita&lt;/a&gt;に投稿してましたが、「〜の設定、手順」や「〜を作ってみた」などは作って終わりという感じでした。
なので、その過程など自分のブログにまとめてしまえば後から見直す時に楽だし、共有もできると思い、&lt;strong&gt;今更ですが&lt;/strong&gt;作りました。（それにこれから先もっと情報量が増えるだろうなと思ったので。）&lt;/p&gt;

&lt;p&gt;後は、単に独自ドメインを取得してブログを自分で作って公開するところまでやってみたいというのもあったからです。&lt;/p&gt;

&lt;p&gt;このブログは、技術的なことを中心とするつもりですが、それ以外のことも載せていく予定です。
マイペース更新ですがよろしくお願いします！&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;自己紹介&#34;&gt;自己紹介&lt;/h3&gt;

&lt;p&gt;こうすけです。名古屋の大学に通っている4年生（17年卒）です。
今年から東京の企業にエンジニアとして就職します。
まだまだ未熟ですがアプリ開発が好きです。アプリを0から作ってApp Storeで公開したりしていました&lt;a href=&#34;http://applion.jp/iphone/app/1089093474/&#34;&gt;。&lt;/a&gt;
趣味はギターで、よく息抜きにアコギを弾いて遊んでます&lt;a href=&#34;https://soundcloud.com/guitar_memo/acoustic-ver&#34;&gt;。&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;この先やってみたいこと&#34;&gt;この先やってみたいこと&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;エンターテイメントを通じて、人々の生活を豊かにするサービスやアプリケーションを形にして届けたい&lt;/li&gt;
&lt;li&gt;人をワクワクさせるものを仲間と作っていきたい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;これからよろしくお願いします。:)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>